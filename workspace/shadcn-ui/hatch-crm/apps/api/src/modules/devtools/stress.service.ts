import { Injectable, Logger } from '@nestjs/common'
import { PrismaService } from '@/modules/prisma/prisma.service'
import { AiEmployeesService } from '@/modules/ai-employees/ai-employees.service'
import { NotificationsService } from '@/modules/notifications/notifications.service'
import { OrgAccountingService } from '@/modules/org-accounting/org-accounting.service'
import { OrgMlsSyncService } from '@/modules/org-mls/org-mls-sync.service'

const sample = <T,>(arr: T[]): T => arr[Math.floor(Math.random() * arr.length)]

@Injectable()
export class StressService {
  private readonly logger = new Logger(StressService.name)

  constructor(
    private readonly prisma: PrismaService,
    private readonly aiEmployees: AiEmployeesService,
    private readonly notifications: NotificationsService,
    private readonly accounting: OrgAccountingService,
    private readonly mlsSync: OrgMlsSyncService
  ) {}

  async runMlsSyncBurst(orgId: string, runs = 5) {
    return this.runParallel(runs, () => this.mlsSync.runSync(orgId))
  }

  async runPersonaBurst(orgId: string, personaId: string, count = 10) {
    return this.runParallel(count, () =>
      this.aiEmployees.runPersona(personaId as any, {
        organizationId: orgId,
        userId: 'stress-user'
      })
    )
  }

  async runAccountingBurst(orgId: string, iterations = 5) {
    const transactions = await this.prisma.orgTransaction.findMany({
      where: { organizationId: orgId },
      take: iterations
    })
    if (!transactions.length) {
      this.logger.warn('No transactions found for accounting stress test')
      return 0
    }
    return this.runParallel(transactions.length, (idx) =>
      this.accounting.syncTransactionToAccounting(orgId, 'stress-user', transactions[idx].id)
    )
  }

  async runNotificationFlood(orgId: string, userId: string, count = 1000) {
    const operations = Array.from({ length: count }).map((_, index) =>
      this.notifications.createNotification({
        organizationId: orgId,
        userId,
        title: `Stress notification ${index + 1}`,
        message: 'Generated by stress harness',
        type: sample(['GENERIC', 'LEAD', 'AI'] as any)
      })
    )
    this.logger.log(`Generating ${count} notifications`)
    const start = Date.now()
    await Promise.allSettled(operations)
    return Date.now() - start
  }

  async runLeadFlood(orgId: string, count = 200) {
    const operations = Array.from({ length: count }).map((_, idx) =>
      this.prisma.lead.create({
        data: {
          organizationId: orgId,
          name: `Stress Lead ${idx}`,
          email: `stress+${idx}@example.com`,
          status: sample(['NEW', 'ACTIVE', 'UNDER_CONTRACT']) as any,
          source: 'MANUAL'
        }
      })
    )
    const start = Date.now()
    await Promise.all(operations)
    return Date.now() - start
  }

  private async runParallel(count: number, fn: (index: number) => Promise<unknown>) {
    const start = Date.now()
    await Promise.all(Array.from({ length: count }).map((_, index) => fn(index)))
    const duration = Date.now() - start
    this.logger.log(`Parallel run (${count}) completed in ${duration}ms`)
    return duration
  }
}
